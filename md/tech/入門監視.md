# 入門監視

## Ch. 1 監視のアンチパターン

- 1 ツール依存
  - 監視では単一の問題ではないので、複数のツールを使用する場合がほとんど
  - ツール導入する際に、たくさんの人と話す。他人に変化を強要しない
  - 「知名度の高い会社が使っているから」という理由でツールを採用しない
  - 自分でツールを作らなければならない時もある
- 2 役割としての監視
  - 監視は役割でなく、スキルである
  - 一人の肩に監視の全責任を押し付けてしまうのはアンチパターン
- 3 チェックボックス監視
  - 監視を設定する人がシステムの動作を完全に理解していない状態
  - まず「動いている」はどう意味なのかを他人に確認して理解する
  - 明確な理由がない限り、OSのメトリクスをアラートとして使わない
  - メトリクスを取得する頻度を上げる
- 4 監視を支えにする
  - 監視する前に、本来存在する問題を解決する
- 5 手動設定
  - できる限り自動化

## Ch. 2 監視のデザインパターン

- 1 組み合わせ可能な監視
  - データ収集
    - プル型: リモートノード + 中央サービス
    - プッシュ型: 一定間隔あるいはイベントが発生したタイミングでプッシュする
    - メトリクス
      - Counter
      - Gauge
    - ログ
      - 非構造化　データ量が少ない場合、わざわざ構造化する必要がない
      - 構造化　JSON
  - データストレージ
    - メトリクス：通常はTSDB(Time Series Database)に保存される
    - ログ
      - rsyslogでログを他のsyslogサーバへ転送
      - Elasticsearchなど検索エンジン
  - 可視化
  - 分析とレポート
    - SLA (Serivice Level Agreement)
  - アラート
    - アラートは監視の結果の一つの形でしかない
    - なので、アラートはメトリクスやグラフなどは一対一対応している必要がない
- 2 ユーザ視点での監視
  - ユーザがアプリケーションとやり取りをするところから監視
  - web nodeやworker nodeまで広げる
  - 常に「このメトリクスはユーザへの影響をどう教えてくれるか」を自問自答
- 3 作るのではく買う
  - 優秀なSaaSを利用する
- 4 継続的改善
  - 2年3年後再構築することになるかも
  - 数ヶ月あるいは数年間にわたる継続した改善

## Ch. 3 アラート、オンコール、インシデント管理

- アラート
  - 手順書: 何らかの問題を解決するのに、人間の判断と診断が必要な時のためのもの
  - 固定のしきい値を決めるだけでなく、変化量など他のものも利用
  - アラートのノイズを減らす
    - そもそもそのアラートは誰がどんなアクションする必要があるのかを考える
    - しきい値を変更できるか監視の内容再設計できるかを常に考える
    - 自動化の仕組み作れるか
  - まず自動復旧を試そう
- オンコール
- インシデント管理
- 振り返り
  - ミスしてインシデントを起こした人に非難しても問題解決しない
  - 問題を覆い隠さざるをえないような雰囲気のチームになる


## Ch. 4 統計入門

## Ch. 5 ビジネスを監視

- アプリケーションやインフラの調子やパフォーマンスを示す先行指標

## Ch. 6 フロントエンド監視

- ゴール
  - 働き続けることではなく
  - 素早くロードされる（実際の収益に直接繋がる）
- アプローチ
  - Real User Monitoring
    - DOMを監視
      - 有益なメトリクス
        - navigationStart
        - domLoading
        - domInteractive
        - domContentLoaded
        - domComplete
      - ページの総ロード時間 = domComplete - navigationStart
      - ページがロードされたとユーザが体感する時間 = domInteractive - navigationStart
  - Synthetic Monitoring
    - WebpageTest.org
    - PRごとにフロントエンドのパフォーマンスへの影響を計測する

## Ch. 7 アプリケーション監視

- メトリクスでアプリケーションを計測する
  - データベースクエリの実行にかかった時間
  - 外部ベンダのAPIが応答するのにかかった時間
  - 1日に発生したログインの数
  - ...
- ビルドとリリースのパイプラインの監視
  - デプロイがいつ始まったか、いつ終わったか、どのビルドがデプロイされたかなどのメタ情報を利用して監視
- health endpoint pattern
  - 利点
    - load balancer, service discoveryによってヘルスチェックにも使用できる
    - 環境内で何が動いているの簡単に判断可能
    - アプリケーション自分自身の健全性を把握できるようになる
  - セキュリティ
    - Webサーバでアクセス制限をかけて、特定のソースアドレスだけがこのエンドポイントにアクセスできるように制限
  - 問題
    - メトリクスベースのやり方より、エンジニアリング作業が多く発生する
    - エンドポイントを継続的に監視するツールも必要
- マイクロサービスの監視
  - 他のアプリケーションと大きな違いがない
  - Distributed tracing


## Ch. 8 サーバ監視

- OSの標準的なメトリクス
  - CPU `top`
    - id: idle
    - us: user
    - su: system
    - ni: niced processes
    - hi: hardware interrupts
    - si: software inteerupts
    - = 100%
  - Memory `free -m`
    - buffer, cached, freeを合計したものを利用可能なメモリ領域とみなすのは厳密的に正確ではない
    - 利用可能なメモリ領域はavailableを確認
  - Network `ip a`
  - Disk sysstat `iostat`
  - Load average `uptime`
    - CPUに処理してもらうのを待っているプロセスがいくつあるか
    - 1分の平均、5分の平均、15分の平均
- SSL証明書
  - 有効期限が切れているかを監視
- Web Server
  - HTTP status codeを監視
  - リクエスト数
  - リクエスト時間
- Database Server
  - Connection
  - Wueries per second
  - IOPS
- Load blancer
- Message queue
  - queue length
  - consumption rate
- Cache
  - Evicted items
  - hit/miss ratio
- DNS
  - Zone transfers
  - Queries per second
- NTP (Network time protocol) Server
- Log
  - HTTP response
  - sudoの使用
  - SSHログイン
  - cronジョブの結果
  - MySQLやPostgreSQLのスロークエリ

## Ch. 9 ネットワーク監視

## Ch.10 セキュリティ監視

## Ch.11 監視アセスメントの実行
