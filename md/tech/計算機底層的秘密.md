# 計算機底層的秘密

## Ch2. 程序運行

### 操作系統，進程與線程

- Program Counter
  - 約等於容量小但速度快的內存
  - 存放CPU即將執行的指令的內存地址
  - 想要讓程序運行起來需要把main的第一條指令寫入PC
- 讓CPU執行程序
  - 在內存中找到一塊大小合適的區域裝入程序
  - CPU寄存器初始化後，找到函數入口設置Program Counter寄存器
- 手動複製太繁瑣，用Loader把程序加載到內存
- 但是如果要在多個程序間切換就需要context，Process用於紀錄這些context
- 用於管理Loader, Process的程序叫做Operating System
- 如果兩個函數的執行是獨立的，可以創建多個進程
  - 但是開銷大
  - 由於進程有自己的地址空間，通信上較為複雜
- PC可以指向任意一個函數讓CPU共享地址空間，執行同一個進程的指令
  - 一個進程可以有多個執行流，也就是Thread
- Thread
  - 線程是操作系統層面的實現，跟有多少個核心沒用直接關係
  - 創建線程需要消耗內存空間
  - 為了減少創建與銷毀的頻率，引入Thread Pool
  - 根據應用的不同，Thread Pool中的Thread數量也不同

### 線程間共享了哪些進程資源

- stack私有的
  - 但是無保護機制
- Read Only的代碼區是共享的
  - 任何一個函數都可以放到線程中執行
- 數據區是共享的
  - 所有的線程都可以訪問 global variables
- Heap是共享的
  - 只要知道變量的地址，任何一個線程都可以訪問該地址指向的數據
- 動態庫中的代碼和數據也是共享的
- Thread Local Storage

### 線程安全

- 問題主要會發生在Heap與數據區
- 如何實現
  - Thread Local Storage
  - Read Only
  - 原子操作
  - 同步互斥

### Coroutine

- Coroutine返回後，runtime的信息是被保存下來的
- Coroutine的目的：以同步的方式進行異步編程

### 徹底理解回調函數